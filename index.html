<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>ゲームパッドクライアント(WebRTC)</title>
  <style>
    html, body { margin:0; padding:0; background:#f4f7fa; width:100vw; min-height:100vh; }
    #pad-status { position:fixed; left:18px; top:18px; width:10px; height:10px; z-index:9999; }
    #pad-status-indicator { display:block; width:8px; height:8px; border-radius:4px; border:1px solid #888; background:#888; transition:background 0.2s; }
    h2, form, #status { max-width:800px; margin-left:auto; margin-right:auto; text-align:center; }
    form { margin-top:24px; }
    .formblock { display:block; margin-top:10px; }
    .big-btn { display:block; width:100%; max-width:500px; margin:24px auto 0 auto; font-size:2.2em; padding:22px 0; background:#2196f3; color:#fff; border:none; border-radius:14px; font-weight:bold; letter-spacing:0.08em; cursor:pointer; transition:background 0.18s; }
    .big-btn:hover:enabled { background:#1565c0; }
    .big-btn:disabled { opacity:0.5; cursor:not-allowed; }
    label { margin-right:12px; }
    select, input[type=text] { font-size:1.1em; padding:4px 8px; }
    #refreshPad { font-size:0.95em; padding:5px 12px; margin-left:8px; }
    #status { margin-top:24px; }
  </style>
</head>
<body>
  <div id="pad-status">
    <span id="pad-status-indicator"></span>
  </div>
  <h2>WebRTC ゲームパッドクライアント</h2>
  <form id="connectform" onsubmit="return false;">
    <label>名前: <input type="text" id="uname" required></label>
    <label>使用ゲームパッド: 
      <select id="padSelect"></select>
    </label>
    <button type="button" id="refreshPad">再検出</button>
    <span class="formblock"></span>
    <button id="connectbtn" class="big-btn" disabled>接続</button>
  </form>
  <div id="status"></div>
  <script>
    // ---- シグナリングWebSocketはクラウドフレアURLで固定 ----
    const SIGNAL_SERVER_URL = "wss://supplement-chosen-merge-zum.trycloudflare.com/ws";
    let ws = null, pc = null, dataChannel = null;
    let connected = false, connecting = false, padIndex = null;

    function updatePadIndicator(active) {
      const el = document.getElementById('pad-status-indicator');
      el.style.background = active ? '#2ecc40' : '#888';
    }
    function setFormLock(isLock) {
      document.getElementById('uname').disabled = isLock;
      document.getElementById('padSelect').disabled = isLock;
      document.getElementById('refreshPad').disabled = isLock;
    }
    function setStatus(text) { document.getElementById('status').textContent = text; }
    function refreshPadList() {
      const pads = navigator.getGamepads();
      const sel = document.getElementById('padSelect');
      sel.innerHTML = "";
      let found = false;
      for (let i = 0; i < pads.length; i++) {
        if (pads[i]) {
          const opt = document.createElement("option");
          opt.value = i;
          opt.textContent = `[${i}] ${pads[i].id}`;
          sel.appendChild(opt);
          found = true;
        }
      }
      if (!found) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "ゲームパッド未検出";
        sel.appendChild(opt);
      }
      document.getElementById("connectbtn").disabled = !found;
    }
    window.addEventListener("gamepadconnected", refreshPadList);
    window.addEventListener("gamepaddisconnected", refreshPadList);
    document.getElementById("refreshPad").onclick = refreshPadList;
    refreshPadList();

    document.getElementById('connectbtn').onclick = () => {
      if (connected || connecting) {
        location.reload();
        return;
      }
      connecting = true;
      setFormLock(true);
      document.getElementById('connectbtn').textContent = '切断';
      setStatus('コントローラー操作待ち...');
      padIndex = parseInt(document.getElementById('padSelect').value);
      watchPad();
    };

    function watchPad() {
      let found = false;
      function loop() {
        const pads = navigator.getGamepads();
        const pad = pads[padIndex];
        if (pad) {
          if (pad.buttons.some(btn => btn.pressed)) {
            found = true;
            startWS(pad);
            return;
          }
        }
        if (!found) requestAnimationFrame(loop);
      }
      loop();
    }

    function startWS(pad) {
      const name = document.getElementById('uname').value.trim();
      ws = new WebSocket(SIGNAL_SERVER_URL); // シグナリングのみ
      ws.onopen = () => setStatus('シグナリングサーバー接続...');
      ws.onmessage = async (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === "offer") {
          pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
          pc.onicecandidate = e => {
            if (e.candidate) {
              ws.send(JSON.stringify({ type: "candidate", candidate: e.candidate }));
            }
          };
          pc.ondatachannel = e => {
            dataChannel = e.channel;
            dataChannel.binaryType = "arraybuffer";
            dataChannel.onopen = () => {
              connected = true;
              setStatus('P2P接続完了！送信開始');
              ws.close(); // シグナリングは不要
              setFormLock(true);
              dataChannel.send(JSON.stringify({ type: "hello", name: name, id: pad.id }));
              startSending();
            };
            dataChannel.onclose = () => {
              setStatus("DataChannel切断");
              connected = false;
              setFormLock(false);
            };
            dataChannel.onerror = () => setStatus("DataChannelエラー");
            dataChannel.onmessage = ev => {
              // サーバーからのレスポンスはここで処理
            };
          };
          await pc.setRemoteDescription(msg.offer);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ type: "answer", answer }));
        } else if (msg.type === "candidate" && pc) {
          await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
        }
      };
      ws.onerror = () => setStatus("シグナリングエラー");
      ws.onclose = () => setStatus("シグナリング切断");
    }

    // --- コントローラバイナリ送信(DataChannel) ---
    function encodeGamepadData(pad) {
      let btnBits = 0;
      for (let i = 0; i < 16; i++) {
        if (pad.buttons[i]?.pressed) btnBits |= (1 << i);
      }
      const axes = [];
for (let i = 0; i < 4; i++) {
  let v = Math.round((pad.axes[i] ?? 0) * 127.5 + 128);
  v = Math.max(0, Math.min(255, v));
  axes.push(v);
}

      let lt = 0, rt = 0;
      if (pad.buttons[6]) lt = Math.round((pad.buttons[6].value ?? 0) * 255);
      else if (pad.axes[4] !== undefined) lt = Math.round(((pad.axes[4] + 1) / 2) * 255);
      if (pad.buttons[7]) rt = Math.round((pad.buttons[7].value ?? 0) * 255);
      else if (pad.axes[5] !== undefined) rt = Math.round(((pad.axes[5] + 1) / 2) * 255);
      lt = Math.max(0, Math.min(255, lt));
      rt = Math.max(0, Math.min(255, rt));
      const buf = new Uint8Array(8);
      buf[0] = btnBits & 0xFF;
      buf[1] = (btnBits >> 8) & 0xFF;
      buf[2] = axes[0] & 0xFF;
      buf[3] = axes[1] & 0xFF;
      buf[4] = axes[2] & 0xFF;
      buf[5] = axes[3] & 0xFF;
      buf[6] = lt & 0xFF;
      buf[7] = rt & 0xFF;
      return buf;
    }
    function isPadNeutral(pad) {
      for (let i = 0; i < 16; i++) if (pad.buttons[i]?.pressed) return false;
      const DEADZONE = 0.07;
      for (let i = 0; i < 4; i++) if (Math.abs(pad.axes[i] ?? 0) > DEADZONE) return false;
      if ((pad.buttons[6]?.value ?? 0) > 0.01) return false;
      if ((pad.buttons[7]?.value ?? 0) > 0.01) return false;
      return true;
    }
    function startSending() {
      let prev = null;
      function loop() {
        const pad = navigator.getGamepads()[padIndex];
        let active = false;
        if (pad && dataChannel && dataChannel.readyState === "open") {
          active = !isPadNeutral(pad);
          const buf = encodeGamepadData(pad);
          let diff = false;
          if (!prev) diff = true;
          else for (let i = 0; i < buf.length; i++) {
            if (buf[i] !== prev[i]) { diff = true; break; }
          }
          if (diff) {
            dataChannel.send(buf.buffer);
            prev = buf;
            setStatus('送信中:');
          }
        }
        updatePadIndicator(active);
        if (connected) requestAnimationFrame(loop);
      }
      loop();
    }
  </script>
</body>
</html>
